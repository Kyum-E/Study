Q0. 안드로이드의 실행환경에 대해서 간단하게 설명하시오.

안드로이드는 크게 4가지 실행환경으로 구성되어있습니다. 
가장 하단부터 리눅스 커널, 라이브러리, 어플리케이션 프레임워크, 어플리케이션 순서입니다. 
리눅스 커널은 OS로 안드로이드 스마트폰의 다양한 하드웨어(화면, 카메라, 블루투스, GPS, 메모리 등)를 관리합니다. 
라이브러리는 안드로이드에 있는 다양한 기능(UI 처리, 미디어 프레임워크, 데이터베이스, 그래픽 처리, 웹 킷 등)을 소프트웨어적으로 
구현해 놓은 환경 뿐만 아니라 안드로이드 앱을 구동해주는 dalvik 가상머신과 코어 라이브러리까지 포함하는 영역입니다. 
어플리케이션 프레임워크는 사용자의 입력(액티비티, 윈도우, 컨텐츠, 뷰, 노티피케이션 등) 또는 특정한 이벤트에 따라 출력을 담당하는 환경을 말합니다. 
마지막으로 실제로 동작하는 앱이 설치되는 환경인 어플리케이션이 있습니다.

Q1. 안드로이드는 다른 플랫폼에 비해 어떤 장점이 있는가?

첫째로 안드로이드를 구성하는 모든 소스가 오픈소스로 무료로 개방되어있어 비용적인 부담이 없습니다. 
또한 전 세계의 수많은 개발자로부터 피드백을 받아 수정되기 때문에 안정성과 버그 수정이 빠릅니다. 
그 밖에도 원한다면 소스를 다운 받아 수정해서 쓰기 편리합니다. 둘째로 자바를 주 언어로 사용하고 있기 때문에 많은 세계적으로 점유율이 높은 자바 개발자들이 
쉽게 개발할 수 있습니다. 셋째로 리눅스 커널을 OS로 채택했기 때문에 다양한 하드웨어에 대한 드라이버 소스가 풍부합니다. 
마지막으로 구글의 다양한 앱과 연동이 매우 편리하며 다른 플랫폼에 비해 앱간 연동에 너그러운편입니다.

Q2. 안드로이드 프로젝트 구성요소에 대해서 설명하시오.

libs : 프로젝트에서 사용하는 다양한 라이브러리 소스가 저장되는 공간입니다.
androidTest : 앱의 일부 코드를 테스트하기 위한 소스를 저장하는 공간입니다.
java : 자바 코드를 저장하는 공간입니다. 표준 자바와 동일하게 패키지를 이용한 하위 디렉토리 생성 방식을 사용합니다.
res : 리소스(이미지, xml 레이아웃, 메뉴, 값)를 저장하는 공간입니다.
AndroidManifest.xml : 앱에 대한 전체적인 정보를 담고있는 파일입니다. 앱의 구성요소와 실행 권한 정보가 정의되어있습니다.
project > build.gradle : 프로그래머가 직접 작성한 그래들 빌드 스크립트 파일입니다.
gradle > build.gradle : 앱에 대한 컴파일 버전정보, 의존성 프로젝트에 대한 정의가 되어있는 파일입니다.

Q3. 안드로이드에서 다국어 지원을 위해 해야할 작업에 대해서 설명하시오.

다국어 지원을 위해서는 value resource file을 따로 생성해주는 방식으로 사용합니다.
'values > 마우스 오른쪽 버튼 클릭 > value resource file > 리소스 파일 이름을 strings로 입력 >
 available qualifiers 탭에서 locale 선택 > language 탭에서 언어 선택 > specific region only에서 세부 국가 선택'
파일을 생성하면 디렉토리의 이름은 values-국가코드(예를 들어 values-kr) 형식으로 생성되며 내부에 strings.xml 파일이 생성됩니다. 
해당 파일에 string의 name 값은 동일하게 유지한 후 해당 국가의 언어로 번역하여 추가하면됩니다.

Q4. 안드로이드 매니페스트(android manifest) 파일에 대해서 설명하시오.

안드로이드 매니페스트는 앱의 이름, 버전, 구성요소, 권한 등 앱의 실행에 있어서 필요한 각종 정보가 저장되어있는 파일입니다. 
반드시 존재해야하는 xml 형식의 파일로 안드로이드 프로젝트의 최상위에 위치하고 있습니다.
가장 최상위는 manifest 태그가 위치하고 있습니다. manifest 태그에는 패키지명, 앱 버전 코드, 앱 버전 이름을 정의합니다.
application 태그에는 앱 아이콘, 앱 이름을 정의합니다. activity 태그에는 액티비티의 클래스명과 액티비티 이름을 정의합니다. 
하위에는 intent-filter 태그를 이용하여 액티비티에 대한 인텐트 작업시 필요한 action과 category를 정의합니다.
service, receiver, provider 태그에는 각각 서비스, 리시버, 프로바이더에 대한 내용을 정의합니다.
permission 태그에는 앱에서 필요한 권한에 내용을 정의합니다.
그 밖에 최소 안드로이드 SDK 버전을 지정하는 uses-sdk와 다른 패키지를 등록할 수 있는 uses-library 태그 등이 존재합니다

Q5. 디스플레이(display), 윈도우(window), 서피스(surface), 뷰(view), 뷰 그룹(view group), 뷰 컨테이너(view container), 
레이아웃(layout)에 대해서 설명하시오.

디스플레이 : 안드로이드 단말기가 가지고 있는 하드웨어 화면을 의미합니다.
윈도우 : 안드로이드에서 실행되는 앱이 그림(뷰)을 그릴 수 있는 영역을 의미합니다. 사용자로부터 입력(터치, 키) 이벤트를 받아 앱에 전달합니다.
서피스 : 윈도우에 그림(뷰)을 그릴 때 그림이 저장되는 메모리 버퍼를 의미합니다.
뷰 : 사용자 인터페이스를 구성하는 최상위 클래스를 말합니다. 윈도우의 서피스를 이용하여 화면에 어떤 모양으로 그림을 그릴지와 발생하는 이벤트를 어떻게 처리할 것인지에 
대한 기능을 구현하고 있습니다. 뷰 중에서 일반적인 제어 역할을 하고 있는 것들을 위젯이라고 합니다.
뷰 그룹 : 여러개의 뷰를 포함하고 있는 뷰를 의미합니다.
뷰 컨테이너 : 다른 뷰를 포함할 수 있는 뷰를 의미합니다. 대표적으로 리스트 뷰(list view), 스크롤 뷰(scroll view), 
그리드 뷰(grid view) 등이 있습니다.
레이아웃 : 뷰 그룹 중에서 내부에 뷰를 포함하고 있으면서 해당 뷰를 어떻게 윈도우에 배치할지 정의하는 관리자 역할을 하는 클래스 말합니다.

Q6. 인플레이션(inflation)이란 무엇인가?

xml 레이아웃 파일로 정의한 정보를 런타임에 setContentView 메소드가 호출됨에 따라 메모리 상에 객체로 만들어주는 과정을 말합니다. 
이 과정에서 xml 레이아웃 파일에서 뷰에 id를 설정하고 해당 id가 R.java 파일에 주소 값으로 환원되며 
findViewById 메소드와 id를 이용하여 코드 상으로 뷰 객체를 가져와 제어할 수 있습니다.

Q7. 안드로이드에서 색상을 지정하는 다양한 방식은 어떤 것들이 있는가?

#RGB, #ARGB, #RRGGBB, #AARRGGBB 총 4가지 방식이 있습니다. 
R은 붉은색, G는 초록색, B는 파란색의 정도를 나타내며 A는 알파 값 즉 투명도를 나타내는 수치입니다. 각각의 요소는 16진수(0부터 F까지)로 표현합니다.

Q8. 안드로이드의 크기를 표현하는 다양한 표현방법에 대해서 설명하시오.

픽셀(px) : 화면의 픽셀을 의미합니다.
밀도 독립적 픽셀(dp, dip) : 160dpi(160인치에 들어가있는 픽셀 수) 화면을 기준으로 한 픽셀을 의미합니다.
축척 독립적 픽셀(sp, sip) : 가변 글꼴을 기준으로 한 픽셀을 의미합니다. 글꼴의 설정에 따라 차이가 있습니다.
텍스트 크기(em) : 글꼴과 상관없이 동일한 텍스트 크기를 표시하기 위한 단위입니다.
그 외 인치(in), 밀리미터(mm)가 있습니다.

Q9. 안드로이드의 4대 컴포넌트(component)에 대해서 간단하게 설명하시오.

안드로이드의 4대 컴포넌트는 액티비티, 서비스, 브로드캐스트 리시버, 콘텐트 프로바이더입니다. 
첫 번째로 액티비티는 안드로이드에서 화면을 관리하고 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다. 
두 번째로 서비스는 화면에서 보이지 않지만 특정한 기능을 백그라운드에서 수행하는 컴포넌트입니다. 
세 번째로 브로드캐스트 리시버는 특정 안드로이드에서 발생하는 특정 브로드캐스트 메세지를 처리하기 위한 컴포넌트입니다. 
네 번째로 콘텐트 프로바이더는 앱간 데이터의 공유를 위해 표준화된 인터페이스를 제공하는 컴포넌트입니다.

Q10. 안드로이드 MVC 모델은 어떻게 구성되어있는가?

안드로이드에서 뷰는 화면에 실제로 보이는 구성을 만드는 영역으로 View 클래스를 상속하는 클래스를 이용하여 구성할 수 있습니다. 
다음으로 컨트롤러는 뷰와 모델을 서로 연결하며 제어하는 영역으로 액티비티, 서비스, 브로드캐스트 리시버, 프래그먼트로 구성됩니다. 
마지막으로 모델은 앱의 다양한 데이터를 저장하는 역할로 SQLite를 이용한 DB, SharedPreference를 이용한 파일 시스템, 콘텐트 프로바이더가 있습니다.

Q11. 액티비티(activity)가 무엇인지와 액티비티 생명주기에 대해서 설명하시오.

안도르이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다.
부모 액티비티에서 새로운 자식 액티비티를 실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가 해줘야합니다. 
다음으로 부모 액티비티에서 startActivity 메소드에 인텐트를 파라미터로 넘겨 실행하거나 startActivities 메소드를 이용하여 여러개의 액티비티를 한꺼번에 실행할 수 있습니다.
액티비티의 실행과정은 첫 번째로 부모 액티비티에서 자식 액티비티를 생성 및 호출합니다. 두 번째로 액티비티 매니저 서비스가 해당 앱 프로세스에서 
인텐트를 복사해온 후 매니페스트 파일에서 해당 인텐트에 명시되어있는 액티비티를 찾고 어떻게 실행시켜야할지 결정합니다. 
세 번째로 찾아낸 액티비티를 실행하고 다시 해당 앱 프로세스에 인텐트를 복사하여 넘겨줍니다. 
그 외 자식 액티비티 내의 onCreate 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게됩니다.
액티비티는 크게 3가지 상태가 존재합니다. 먼저 실행(running) 상태는 액티비티 스택의 최상위에 있으며 포커스를 가지고 있어 사용자에게 보이는 상태입니다. 
다음으로 일시 중지(paused) 상태는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태를 말합니다. 
예를들어 대화상자가 위에 있어 일부가 가려져 있는 경우를 말합니다. 마지막으로 중지 (stopped) 상태는 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태를 말합니다.
액티비티가 처음 만들어지면 onCreate 메소드가 호출되어 레이아웃을 구성합니다. 이후 onStart 메소드가 화면에 보이기 직전에 호출됩니다. 
다음으로 onResume 메소드가 사용자 상호작용(화면이 포커스를 얻었을 때)하기 바로 전에 호출됩니다. 이 3가지 메소드가 호출되어 액티비티는 실행 상태를 갖게됩니다. 
이후 포커스를 잃었을 때 onPause 메소드가 호출되고 일시 중지 상태가 됩니다. 일시 중지 상태에서 다시 포커스를 획득하면 onResume 메소드가 호출되거나 
다른 액티비티에 의해서 완전히 화면이 가려졌는지 여부를 확인하여 가려져 보이지 않는 경우 onStop 메소드가 호출되어 중지 상태가됩니다. 
정지 상태에서 다시 화면이 보이기 직전에 onRestart 메소드가 호출되고 onStart 메소드가 차례로 호출됩니다. 그 외 finish 메소드가 실행되어 
해당 액티비티가 종료되기 직전에 onDestroy 메소드가 실행됩니다.
가끔은 일시 중지나 중지 상태에서 시스템이 메모리가 부족하다고 판단될 경우 onCreate 메소드부터 다시 해당 액티비티를 구동합니다. 
이 경우 onStop, onResume 메소드 호출이 생략됩니다. 따라서 onSaveInstanceState, onRestoreInstanceState 메소드를 이용하여 
액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의해줄 수 있습니다.


Q12. 액티비티간 데이터 전달에서 임의의 클래스 객체를 바로 전달하지 못하는 이유는 무엇이고 전달하기 위해서는 어떤 처리가 필요한가?

액티비티간 전달할 수 있는 데이터의 type은 보통 기본형으로 정해져있습니다. 그 이유는 인텐트를 이용하여 액티비티의 데이터를 전달하는 과정에서 
현재 실행중인 앱 프로세스가 시스템 프로세스로 실행중인 액티비티 매니저 서비스 프로세스에게 인텐트를 전달합니다. 
이 경우 프로세스간 통신이기 때문에 인텐트에 있는 값들을 복사하여 넘기는 방식으로 처리되기 때문에 객체 주소를 바로 넘기지 못하는 문제가 발생합니다. 
따라서 이 문제를 해결하기 위해 자신이 임의로 만든 클래스 객체를 전달하기 위해서는 Serilizable이나 Parcelable 인터페이스를 상속받아 객체를 
직렬화하여 넘기는 방식을 사용해야합니다.



Q13. 부모 액티비티에서 자식 액티비티의 결과 값을 받아오기 위해 어떻게 해야하는가?

먼저 부모 액티비티에서 startActivityForResult 메소드를 이용하여 인텐트와 리퀘스트 코드를 파라미터로 넘깁니다. 
이후 자식 액티비티에서 setResult 메소드에 결과 코드와 데이터를 파라미터로 넘깁니다. 
다시 부모 액티비티에서 onActivityResult 메소드를 오버라이딩하여 자식 액티비티에서 보낸 결과 코드와 데이터를 받아 처리하는 코드를 작성할 수 있습니다. 
이후 실행과정에서 자식 액티비티의 finish 메소드가 호출되면 부모 액티비티가 다시 화면에 나타나면서 onResume 메소드가 실행됩니다. 
이때 onActivityResult 메소드가 작동하게 됩니다.


Q14. 안드로이드가 리소스(resource)를 접근하는 방식에 대해서 설명하시오.


Q15. 서비스(service)가 무엇인지와 서비스 생명주기에 대해서 설명하시오.

서비스는 백그라운드에서 실행되는 구성 요소입니다. 서비스는 사용자에게 보이는 화면이 존재하지 않으며, 정해지지 않은 시간 동안 운영됩니다. 
각각의 서비스는 매니페스트 파일에 서비스 태그를 이용하여 선언해야합니다. 
서비스는 Service 클래스를 상속받아 onStartCommand 또는 onBind 메소드를 재정의하여 구현할 수 있습니다.
서비스는 다른 구성 요소들처럼 메인 쓰레드에서 동작합니다. 따라서 CPU를 많이 사용하거나 대기 상태를 필요로 하는 경우 새로운 쓰레드를 이용하여 생성해야합니다. 
또한 서비스의 객체는 단말에서 오직 1개만 생성되어 관리합니다.
먼저 서비스가 startService 메소드로 실행되는 경우 서비스가 생성될 때 onCreate 메소드가 실행됩니다.
이후 서비스가 실행을 시작할 때 onStartCommand 메소드가 호출되며 서비스의 상태가 실행중으로 변경됩니다. 
이후 stopService 메소드가 실행되면 서비스가 종료되며 onDestroy 메소드를 호출하며 서비스의 상태가 종료로 변경됩니다.
다음으로 서비스가 bindService 메소드로 실행되는 경우 서비스가 생성될 때 onBind 메소드가 호출됩니다. 
다음으로 unbindService 메소드가 호출되어 바인딩이 해제되면 onUnbind 메소드가 호출됩니다. 이후 완전히 종료될 때 onDestroy 메소드가 호출됩니다.


Q16. 브로드캐스트 리시버(broadcast receiver)가 무엇인가?



Q18. 인텐트(intent)와 인텐트 필터(intent filter)에 대해서 설명하시오.

Intent : 어떤 Activity에 데이터를 보낼 때 값들을 지정하기 위해 사용

인텐트필터 : AndroidManifest.xml에서 설정하는 암시적 인텐트 (받는 쪽에서 설정 함)

             즉, 인텐트를 보내는 앱에서는 받는 앱의 이름을 알 필요가 없다.



Q19. 어플리케이션(application)과 컨텍스트(context)에 대해서 설명하시오.

어플리케이션 앱 프로세스가 실행되면 가장 먼저 생성되는 객체로 하나의 어플리케이션 객체는 하나의 앱 프로세스와 대응됩니다. 
앱이 백그라운드로 내려가도 앱 프로세스는 계속 살아있기 때문에 어플리케이션 객체도 살아있다고 할 수 있습니다.

컨텍스트는 안드로이드의 컴포넌트들이 동작하기 위해 필요한 정보를 담고 있는 객체를 말합니다.
각각의 컴포넌트들(액티비티, 서비스, 브로드캐스트 리시버 등)은 자신만의 컨텍스트를 가지고 있습니다. 컨텍스트 내에는 어플리케이션의 정보(패키지명 등), 
컨텍스트가 실행되는데 필요한 정보(테마 등)를 얻거나 시스템 서비스(윈도우 매니저, 레이아웃 인플레이터 등)를 구동하는데 사용됩니다.


Q20. 노티피케이션(notification)은 무엇인가?

Q21. 안드로이드에서 로그(log)를 출력하는 방법과 종류를 설명하시오.

Q22. 스타일(style), 테마(theme)에 대해서 설명하시오.

Q23. 프레그먼트(fragment)가 와 프레그먼트 생명주기에 설명하시오.

프레그먼트는 액티비티의 일부분에만 배치되는 화면 및 동작을 조작하기 위한 객체입니다. 안드로이드 3.0(허니콤)에서 화면이 비교적 큰 태블릿의 등장으로 
작은 단위의 화면의 생명주기 관리할 필요가 있어 추가되었습니다. 프레그먼트 매니저를 통해서 여러개의 프레그먼트를 조작할 수 있습니다. 
레이아웃 xml 파일에서 다른 뷰들과 함께 배치될 수 있습니다.

액티비티가 생성되면 프레그먼트 매니저는 초기화(initializing) 상태가 됩니다. 
프레그먼트가 매니저에 의해 추가되면 onAttach, onAttachFragment, onCreate 메소드가 차례로 실행됩니다. 
다음으로 액티비티의 onCreate 메소드 호출 이후 매니저는 생성(created) 상태로 변경됩니다. 
이때 onCreateView, onViewCreated, onActivityCreated 메소드가 차례로 호출됩니다. 
다음으로 액티비티의 onStart 메소드가 호출되면 매니저는 시작(started) 상태로 onStart 메소드를 호출합니다. 
이후 액티비티의 onResume 메소드가 호출되면 매니저 역시 재시작(resume) 상태로 변하며 onResume 메소드를 호출합니다. 
그 외 액티비티가 화면에서 보이지 않을경우 호출되는 onStop 메소드 호출 이후 매니저는 중지(stop) 상태가 되며 
액티비티의 onDestroy 메소드 호출 이후 매니저는 onDestroyView 메소드를 호출합니다.



Q24. 뷰 홀더 패턴(view holder pattern)에 대해서 설명하시오.

Q25. 나인패치(9patch)란 무엇인가?

Q26. 태스크(task)란 무엇인가?

예를들어 어떤 앱에서 앨범 앱을 실행하는 기능이 있다면 이 앱은 두개의 앱을 실행하는 형태가 되지만 사용자 입장에서는 하나의 앱에서 화면이 전환된다고 판단합니다. 
이와 같은 사용자 입장에서 논리적인 화면 구성의 단위를 태스크라고 말합니다.


Q27. 안드로이드의 메모리 관리 방식에 대해서 설명하시오.

안드로이드는 액티비티, 서비스, 리시버, 프로바이더를 실행하기 위해 앱이 실행되는 과정에서 프로세스를 생성합니다. 
실행중인 모든 앱은 컴포넌트가 모두 종료되어도 다음에 이 앱을 다시 실행할 가능성이 높기 때문에 프로세스를 바로 제거하지 않습니다. 
바로 종료하지 않는 이유는 앱을 실행하기 위해 프로세스를 생성하는 과정에서 딜레이가 발생하는데 이 딜레이를 줄이기 위함입니다. 
따라서 사용자에 의해 다시 앱이 실행되면 남아있던 프로세스가 존재하는 경우 바로 실행됩니다. 
이 과정에서 쌓여있던 많은 프로세스로 인해 메모리가 부족해지는 경우 프로세스의 우선순위(사용빈도)에 따라 프로세스를 종료하여 메모리를 확보합니다.

RxJava란 무엇인가?

일단 RxJava는 Reactive Programming을 기반으로 한 언어입니다. 즉 Reactive Extension의 JVM버전입니다.
비동기 데이터처리를 효율적으로 할 수 있는 장점이 있습니다. RxJava는 반응형 프로그래밍으로 명령형 프로그래밍과 다른 개념입니다.

반응형 프로그래밍의 특징

for if while같은 것이 아니라 sql 쿼리 같은 선언형으로 구성됩니다.
또 함수를 단지 호출하는 대상이 아니라 변수로도, 혹은 인자로도 넘길 수 있습니다.
이러한 함수형언어의 도구들을 자유롭게 활용해야 합니다(ex) java8의 람다표현식)

안드로이드의 테스크란?

Task는 어플리케이션에서 실행되는 Activity를 관리하는 스택입니다. 선입 후출의 형태로 나중에 적제된 액티비티가 가장 먼저 사용됩니다. 
최초적재된 엑티비티는 Root Activity라고 하고 마지막에 적재된 Activity는 Top Activity라고 합니다. Flag를 이용하여 엑티비티의 흐름을 제어 할 수 있습니다.

Restful API란?       *Representation State Transfer의 약자

웹상에 존재하는 모든 자원에 URI를 부여하여 사용하는 방법이다. (비연결성, URI로 자원에 접근) HTTP 웹 표준을 이용하며 http의 캐싱을 활용 할 수 있다는 장점이 있다. 
그리고 구조가 명확하여 클라이언트와 서버에서 개발해야할 부분이 명확해지고 Uri만 봐도 어떤 요청인지 파악될 수 있게 
직관적이다라는 특징이 있습니다.


FCM의 구동 원리? (Firebase Cloud Messaging의 약자)

본연의 서버의 기능을 수행하면서 또 하나의 복잡한 알림 기능까지 포함한다면 서버의 속도는 처리량이 많아 느려질 것이다. 
따라서 이러한 해결책으로 알림의 기능은 다른 서버가 제공을 해주고 본 서버는 알림기능을 제공하는 서버에 알림이 있는지 요청을 해서 정보를 가져오는 구조이다.
FCM의 동작을 위해서 HTTP나 XMPP로 FCM과 통신하는 서버와 클라이언트 앱이 필요합니다.

동작 순서
디바이스에 앱이 설치된후 최초 실행되면서 고유 식별자인 디바이스 토큰이 발급된다. 이 토큰을 앱 서버에 등록한다.
앱 서버에서 FCM 연결 서버로 푸시 알림을 요청한다. 이때 준비물은 디바이스 토큰과 API 서버 키이다.
FCM 연결 서버는 토큰을 대상으로 알림 메시지를 푸시한다.

Looper란 무엇인지 설명해보세요.

Looper는 스레드간의 신호이므로 handler에 보낸다고 해서 곧바로 처리되는 것이 아닙니다. 
동시다발적으로 메세지가 발생할 수 있기 때문에 메세지 큐(Message Queue)에 쌓았다가 처리합니다. 
큐(Queue)에 들어있는 내용을 하나하나 꺼내 처리하는 놈이 바로 루퍼입니다. 메인 쓰레드가 looper를 가지고 있으며 무한 루프를 돌며 큐의 내용을 처리합니다.

쓰레드간 통신방법에 대해 설명해보세요.

1. Java IO에서 제공하는 파이프를 이용한 방법
2. 쓰레드간의 공유메모리를 통한 접근 (인스턴스 맴버변수,클래스멤버변수)
3. synchronized를 이용한 시그널링
4. BlockingQueue를 이용한 방법

안드로이드 스레드 통신 메커니즘을 알기 위해서는 android.os 패키지 안의 다음 사항을 알아야 한다.

핸들러 - 루퍼 - 메시지 큐 - 메시지
android.os.Looper : UI 스레드에 하나가 존재하며 소비자 스레드와 연관된 메시지 발송자 (데이터를 읽는 역활) (소비자 => 데이터를 읽는다)
android.os.Handler : 큐에 메시지를 삽입하는 생산자 스레드를 위한 인터페이스와 소비자 스레드 메시지 처리, 하나의 Looper 객체는 많은 핸들러를 갖지만 모두 같은 큐에 삽입
android.os.MessageQueue : 소비자 스레드에서 처리할 메시지들이 담긴 무제한의 연결 리스트. 모든 루퍼와 스레드는 최대 하나의 메시지 큐를 가진다.
android.os.Message : 소비자 스레드에서 실행하는 메시지

Intent Flag - FLAG_ACTIVITY_CLEAR_TOP, FLAG_ACTIVITY_SINGLE_TOP에 대해 설명
FLAG_ACTIVITY_SINGLE_TOP => 동일한 액티비티가 연속적으로 호출될경우 1개로 취급
FLAG_ACTIVITY_CLEAR_TOP => 동일한 액티비티가 쌓일경우 rootActivity만 남기고 제거


안드로이드에서 메모리 관리

안드로이드에서 메모리 관리는 GC를 이용해서 진행되게 됩니다.
주기적으로 GC루트에서 모든 객체 참조에 대해 활성객체를 표시하고 활성되지 않은 객체는 메모리에서 지워집니다.
String References와 WeakReference로 나눌 수 있습니다.


안드로이드의 메모리 구조

안드로이드의 메모리구조를 보면 램, 내장메모리, 외장메모리로 구분됩니다.
렘 : 프로그램이 실행될때 상주되는 공간입니다. 평상시에 하드에 저장되어있다가 런타임시에 차지되는 공간을 말합니다.
내장메모리 : 간단하게 하드디스크라고 생각해도 됩니다.
외장메모리 : 메모리가 더 필요할때 추가 할 수 있는 메모리입니다.

안드로이드 HTTP 라이브러리의 역사

2007년 => 안드로이드 발표 , HttpClient, 아파치의 DefaultHttpClient등이 사용
            (HttpClient의 여러 버그들 문제가 있음)
2011년 => Goolge의 Developer 블로그에서 HttpUrlConnetction 사용 권장
이후... => Volley나 Square의 Okhttp가 등장하여 쉽게 Http 통신을 사용할 수 있게 됨.
2014년 => 롤리팝 이후 HttpClient 가 Deprecated되며 이를 베이스로 하는 Volley도 Deprecated됨
이후.... => Okhttp와 그 래퍼인 Retrofit이 인기를 가짐. Retrofit은 클라이언트 부분과 콜백 형식등을 플러그로 변경할수 있다는점에서 인기를 가짐.


PendingIntent에 대해서 설명해주세요.


Intent를 직접 보내지 않고 다른 클래스에서 Intent를 위임해주기 위한 클래스이다. 보통 NotificationBar와 상호작용 하는 어플리케이션을 작성할때 사용된다.
즉 알림바, 알람, 다른앱에서 startActivity,sendBroadCast,StartService가 실행되게 하고 싶을때 Intent를 PendingIntent에 담아서 호출한다.


1. View가 그려지는 과정

뷰는 포커스를 얻으면 레이아웃을 그리도록 요청한다. 이때 레이아웃의 계층구조 중 루트 뷰를 제공해야한다. 따라서 그리기는 루트노드에서 시작되어 트리를 따라 전위 순회 방식으로 그려진다. 
부모 뷰는 자식 뷰가 그려지기 전에(즉, 자식 뷰 뒤에) 그려지며 형제 뷰는 전위 방식에 따라 순서대로 그려진다. 
레이아웃을 그리는 과정은 측정(measure)단계와 레이아웃(layout)단계를 통해 그려지게 된다.

측정단계 - measure(int widthMeasureSpec, int heightMeasureSpec)
부모노드에서 자식노드를 경유하며 실행되며, 뷰의 크기를 알아내기 위해 호출된다. 이것은 뷰의 크기를 측정하는 것은 아니며, 
실제 크기 측정은 내부에서 onMeasure(int, int)를 호출하여 뷰의 크기를 알아낸다. 측정 과정에서는 부모 뷰와 자식 뷰간의 크기정보를 전달하기 위해 2가지의 클래스를 사용한다.

ViewGroup.LayoutParams
자식 뷰가 부모 뷰에게 자신이 어떻게 측정되고 위치를 정할지 요청하는데 사용된다. 
ViewGroup의 sub class에 따라 다른 ViewGroup.LayoutParams의 sub class가 존재할 수 있다. 
예를 들어 ViewGroup의 sub class인 RelativeLayout 경우 자신만의 ViewGroup.LayoutParams의 sub class는 
자식 뷰를 수평적으로 또는 수직적으로 가운데정렬을 할 수 있는 능력이 있다.

숫자 (ex. android:layout_width=”320dp”)
MATCH_PARENT (ex.android:layout_width=”match_parent”)
WRAP_CONTENT (ex.android:layout_width=”wrap_content”)
ViewGroup.MeasureSpec
부모 뷰가 자식 뷰에게 요구사항을 전달하는데 사용된다.

UNSPECIFIED - 부모 뷰는 자식 뷰가 원하는 치수대로 결정한다.
EXACTLY - 부모 뷰가 자식 뷰에게 정확한 크기를 강요한다.
AT MOST - 부모 뷰가 자식 뷰에게 최대 크기를 강요한다.
레이아웃단계 - layout(int l, int t, int r, int b)
부모노드에서 자식노드를 경유하며 실행되며, 뷰와 자식뷰들의 크기와 위치를 할당할 때 사용된다. measure(int, int)에 의해 각 뷰에 저장된 크기를 사용하여 위치를 지정한다. 
내부적으로 onLayout()를 호출하고 onLayout()에서 실제 뷰의 위치를 할당하는 구조로 되어있다.

measure()와 layout()메소드는 내부적으로 각각 onMeasure()와 onLayout()함수를 호출한다. 
이것은 final로 선언된 measure()와 layout() 대신 onMeasure()와 onLayout()을 구현(override)할 것을 장려하기 위해서이다.

뷰의 measure()메소드가 반환할때, 뷰의 getMeasureWidth()와 getMeasureHeight()값이 설정된다. 
만약 자식 뷰 측정값의 합이 너무 크거나 작을 경우 다시 measure()메소드를 호출하여 크기를 재측정한다.

View life cycle
 1. Constructor : 생성자, 초기화 AttributeSet 인터페이스 지원 attrs.xml 파일 만들고 호출 뷰의 설정값 설정
 2. onAttachedToWindow : 부모 뷰가 addView(childView) 를 호출한 후 childview는 윈도우에 붙게 되고 이때부터 id를 통해 접근
 3. onMeasure : 뷰의 크기를 측정하는 매우 중요한 단계 레이아웃에 맞게 특정 크기를 가져야 한다. 
	(뷰가 원하사이즈 계산, MeasureSpec에 따라 크기와 모드를 가져온다. MeasureSpec의 mode를 체크하여 뷰의 크기를 적용)
 4. onLayout : 뷰의 크기와 위치를 할당
 5. onDraw : 뷰를 실제로 그리는 단계, onDraw 메소드는 빈번하게 호출 된다. (Scroll 또는 Swipe 등 할경우 뷰는 다시 onDraw와 onLayout을 다시 호출)
...
View Update
 View lifecycle을 보면 뷰를 다시 그리도록 유도하는 invalidate() 와 requestLayout() 메소드가 있다 
1. invalidate() : 단순히 뷰를 다시 그릴때 사용, onDraw() 메소드를 재호출하면서 뷰를 업데이트 한다.
2. requestLayout() :  onMeasure() 부터 다시 뷰를 그린다. 사이즈 변경이 생긴 경우 사용 하면 유용

Animation
뷰의 animation은 frame 단위의 프로세스, 각단계 마다 invalidate()를 호출 하여 뷰 갱신. 대표적으로 Animation에 사용하는 클래스는 ValueAnimator


대용량 Bitmap 로드시 메모리 문제를 해결하는 방법

1.createScaledBitmap : 비트맵을 생성할때 작은 크기로 생성하여 메모리 사용을 줄일수 있다.
(장점. 원하는 크기로 비트맵이 나온다 비율이 안맞을수 있음, 단점. 이미 원본 비트맵이 메모리에 로드되어 있어야 리사이즈 된 비트맵을 생성할 수 있다.)

2.BitmapFactory.Options.inSampleSize : 플래그 값을 1이 아닌 값으로 두면 실제 크기의 이미지를 로드할 필요 없는 원본 사이즈의 값을 가징 이지로 나온다.
예로 2 -> 1/2 크기가 나옴 (장점 속도가 빠르다, 단점 2의 지수가 아닌값으로 리사이징 못한다.)

3.BitmapFactory.Options.inScaled/BitemapFactory.Options.inDensity : 어떠한 사이즈든 리사이징이 가능하고 리사이징 필터가 적용되어 더욱 정교하다.
하지만 추가적인 필터링 단계는 많은 시간이 소요되며 inSampleSize에 비해 느리다

4.Combine inSampleSize, inScaled & inDensity : 원하는 이미지 크기보다 2배 큰 이미지를 inSampleSize를 통해 리사이징하고 원하는 크기까지는 
inScaled와 inDensity를 이용하여 정교하게 리사이징하여 원하는 크기의 이미지를 얻는다(문제점 이미지의 원래 크기를 구하는 방법이 어렵다)

5.Bitmap.Options.inJustDecodeBounds :  원본 Bitmap 객체를 생성하지 않은 채로 원본 이미지 크기를 구할시 inJustDecodeBounds옵션을 이용한다. 
이것의 값이 true일 경우 BitmapFactory.decodeFile(fileName, Options)를 통해 Bitmap을 생성시 Bitmap 객체를 반환하지 않고 Bitmap 정보를 Options 객체에 담는다. 
따라서 Options.outWidth, Options.outHeight를 통해 너비와 높이를 알 수 있다. 
반대로 Bitmap 객체를 생성하고 싶을 경우 inJustDecodeBounds 값을 false로 설정하여 decode하면 객체를 반환한다.

이미뷰에서 scale을 저정할 수 있는데 왜 비트맵을 지접 조정했나.

길이가 제각각인 이미지를 서버로 받아서 동일한 크기의 이미지로 자른 후  총 개수를 파악하여 이미지뷰를 인플레이션 해야 했고
각각의 이미지뷰에 정해진 이미지를 보여 주려면 비트맵으로 변환하여 가공하는 과정이 필요했다.

1. Picasso
Picasso는 Square Inc.가 개발한 이미지로드 라이브러리이다. 그리고 Square Inc.에서 개발한 HTTP 클라이언트 오픈 소스인 
OkHttp를 HTTP 클라이언트로 활용한다. 메서드 체인 방식이라 직관적이고 사용하기 편리하다.

특징 및 기능
이미지의 원본 사용
기본 ARGB_8888, RGB_565 변환 가능
웹에서 이미지 로딩
메모리 및 디스크 캐싱
명시적으로 이미지 Resize 가능, 변형(Transforming)
Snapshot : 이미지에 대한 모든 정보를 텍스트로 출력
Debug Indicators : 이미지가 네트워크, 디스크 캐시, 메모리 캐시 중 어디에서 왔는지를 리본의 색깔로 나타내는 기능

장점
이미지로딩 라이브러리 중 가장 가벼움
빠른 캐시 속도
순차적 다운로드 및 빠른 다운로드
사용하기에 간단함

단점
기본적으로 많은 메모리 사용 (원본 이미지를 디스크에 저장하고 메모리에 할당하기 때문에)
resize 처리 및 fit 메서드를 통해 해결 가능
ImageView의 크기를 고정으로 하는 것이 가장 좋은 방법
비교적 정보 부족(?)

2. Glide
Glide는 Google에서 개발한 이미지로드 라이브러리.

특징 및 기능
기본 RGB_565(Half size), ARGB_8888 변환 가능
ImageView에 맞게 Resize
Custom animation & transformation
GIF, Thumbnail 지원

장점
많은 커스텀 기능 제공
빠른 로딩 속도
비교적 정보 많음
사용하기에 간단함

단점
무거움

Retrofit
사용한 이유
REST API 라이브러리 중 가장 좋은 성능
AsynTask, HttpURLConnection에 비해 훨씬 간단한 구현 방법


this와 getApplicationContext의 차이점
 this는 항상 현재 클래스 객체를 가리키고, appcontext는 전체 프로세스를 가리킨다.

UI 반응 제한 시간
 터치는 5초 내에 처리 되지 않을때, 브로드캐스트는 10초 내에 처리되지 않았을 때

bundle과 parcel의 차이점
bundle은 액티비티간 주고 받는 데이터를 보유한 데이터 holder. 액티비티 강제 종료시에 나중에 액티비티 상태들을 모두 저장
하고 onCreate 함수에 전달되어 액티비티를 복원한다. 메모리 부족이나 회전시에 발생
onSaveInstanceState() : onPause() 이전 또는 이후에 호출
onRestoreInstanceState() : onStart() 이후에 호출된다

parcel은 범용 직렬화 메커니즘이 아니다. 고성는 ipc 전송으로 설계 되었고 IBinder에 많이 사용된다.

Fragment와 Activity 차이
플래그먼트는 액티비티에 종속 더 넓은 스크린 장치 내의 공간을 효율적으로 이용하기 위해 사용

하나의 액티비티는 스크린 사이즈에 따라 0개 또는 여러개의 플래그먼트들을 포함하고 있다. 여러개의 액티비티에서 재사용
할수 있기 때문에 재사용 가능한 component 처럼 동작 

플래그먼트는 독립적으로 존재 할수 없다. 액티비티 안에 있어야 한다.


스레드와 서비스 차이점
서버스는 ui 없이 백그라운드에서 오랫동안 작업을 수행하기 위한 안드로이드 component 중 하나
스레드는 백그라운드에서 몇몇 작업을 수행하기 위한 os레벨에서의 기능

sharedpreference 
안드로이드 데이터를 저장하는 가장 간단한 방법 key와 value 쌍형태로 xml파일로 저장
기본데이터 형태(boolean, float, int, long,string)로만 저장, 저장된xml은 data/data/shared-prefs

Service Lifecycle에서 요구되는 단계들
서비스는 start서비스 함수를 통해 시작되고 시스템에서 onCreate 메소드를 사용하여 서비스를 검색
서비스를 시작하기 위해 onStartCommand 메소드 적절한 arguments 들고 함께 호출해야 한다.



안드로이드의 시스템 구조 참고링크

(버블, 퀵, 삽입 등) Sort 알고리즘을 구현 참고링크

자바와 관련하여 Call by Value와 Call by Reference에 대해 설명.
Call by value : 메서드 호출시에 사용되는 인자의 메모리에 저장된 값을 복사해서 보낸다.
Call by reference : 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 주소를 복사해서 보낸다.

Process와 Thread 설명 및 차이점
프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것.
스레드는 프로세스의 실행 단위. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.

인텐트(Intent)에 대해서

일종의 메시지 객체. 이를 사용해 다른 컴포넌트에 작업을 요청할 수 있다.
기본적으로 액티비티 시작, 서비스 시작, 브로드캐스트 전달에 사용된다.
명시적인텐트 : 특정 컴포넌트 클래스를 이름으로 직접 지정
암시적인텐트 : 해당 기능을 가지고있는 불특정한 앱들을 찾을 때 사용

안드로이드 앱을 구성하는 4대 구성요소는?

Activity
Service
Content provider
BroadCast Receiver

Activity간 데이터 전달에서 POJO(Plain Old Java Object)를 전달하지 못하는 이유와 해결방법

이유 : 인텐트를 전달할때는 IPC를 이용한다. 그러나 프로세스간 통신시에는 메모리참조가 안된다. 그래서 파일에 쓰는 방식을 이용하는데 이 때 직렬화, 역직렬화를 통해 파일을 참조한다.
해결방법 : 
Serializable : implements Serializable 추가하면 됨 사용이 간편한만큼 내부적으로 자바의 리플렉션이 발생하게 되고 그로 인해 많은 오브젝트 생성과 그에따른 GC가 발생 하게 되어 성능저하와 배터리 이슈 발생

Parcelable : 안드로이드 sdk에 포함 되어 있으며, Parcelable은 리플렉션을 사용하지 않기 위해 설계 되어 있다. 리플렉션을 없애기위해 유지보수가 힘든 보일러플레이트 코드가 생성성되었지만 퍼포먼슨 향상됨
안드로이드에서는 Parcelable 을 쓰는 이유 : 참고링크_아래에 있음

Reflection(리플렉션) : 자바 언어의 기능중 하나로 프로그램 내부 속성을 조작 할 수 있게 한다.


안드로이드의 프로젝트 구성요소에 대해 설명(Manifest, gradle, src, res 등)

Manifest : 애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야한다. 공식문서
gradle : 고급 빌드 툴킷인 Gradle을 사용하여 빌드 프로세스를 자동화하고 관리하는 한편, 여러분은 유용한 사용자 지정 빌드 구성을 정의할 수 있습니다. 공식문서
src : JUnit 테스트 코드를 비롯한 Java, kotlin 소스 코드 파일을 포함합니다. 이들 파일은 패키지 이름별로 구분
res : 코드가 아닌 모든 리소스(예: XML 레이아웃, UI 문자열, 비트맵 이미지 등)를 포함합니다. 이들 리소스는 해당 하위 디렉토리로 나뉩니다.
데드락이란?
 프로세스간 공유자원을 사용하는 과정에서 발생할수 있는 "죽어있는 잠김 상태"
데드락 발생 조건
데드락 회피방법

안드로이드의 inflate에 대해서 설명해보세요

안드로이드 수치(DP)에 대해서 설명해보세요 공식문서

목적 : 다양한 화면 크기에서 동일 비율로 출력되도록 하는 픽셀 단위
예시 : px = dp * (dpi / 160)

배우고 싶은 기술은?

기술 트렌드 학습 하는법

접근 지정자에 대해서 설명

쓰레드 동기화 방법에 대해서 설명

해시맵 사용할 때 주의할 점

onTouchEvent 리턴값의 의미
true : 그 뒤 리스너까지 이벤트를 전달하지 않고, 터치만 하고 끝낸다.
false : 그 뒤 이벤트까지 액션을 전달한다.
이벤트를 사용할 경우 true

안드로이드 O의 변경사항 공식문서

ListView와 RecyclerView의 차이점

LRU캐시에 대해서 아는대로 설명해보세요.

페이지 교체 알고리즘은 페이징 기법으로 메모리를 관리하는 운영체제에서, 페이지 부재가 발생 하여 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할지를 결정하는 방법입니다.
페이지 교체 알고리즘의 예로, FIFO, LFU, LRU 알고리즘 등이 있습니다.

FIFO : 페이지가 주기억장치에 적재된 시간을 기준으로 교체될 페이지를 선정하는 기법
단점 : 중요한 페이지가 오래 있었다는 이유만으로 교체되는 불합리. 가장 오래 있었던 페이지는 앞으로 계속 사용될 가능성이 있음.

LFU : 가장 적은 횟수를 참조하는 페이지를 교체
단점 : 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 프로그램을 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드 발생

LRU : 가장 오랫동안 참조되지 않은 페이지를 교체
단점 : 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야함. 큰 오버헤드가 발생

MVC, MVP, MVVM의 차이점

VCS(git, svn 등) 사용 경험 여부 및 특징에 대해 설명

RxJava사용경험 여부

안드로이드 앱 개발 대표 라이브러리들 사용경험(Realm, Glide 등..)

Generic과 Type캐스팅의 차이점

Serializable 과 Parcelable의 차이는? https://band.us/band/71578699/post/80

CI(Jenkins,CircleCI) 사용경험

NDK 개념

Primitive타입과 Wrapper클래스에 대해 설명

사용해본 디자인 패턴에 대해 설명(Singleton, Observer, Factory 등등)

AsyncTask에 대해 설명

TDD에 대해서 아는대로 설명

A/B테스트란

임의로 두 집단을 나누고, 기존 프로그램과 새로운 프로그램을 보여준 후 어떤 집단이 더 좋은 성과을 보였는지 측정하여 새로운 프로그램이 좋은지 정량적으로 평가하는 방식
웹툰 및 전자책과 같은 앱을 구현하기위해 ViewPager를 사용한다 가정하고, 메모리와 관련해서 어떤방식으로 구현할지 설명하시오.

자료 구조와 관련한 질문(예: 좋아하는 언어로 연결리스트를 구현해보세요(화이트보드 또는 컴퓨터에 작성))

Dependency Injection이란?

디자이너 또는 기획자와 이견이 생길때 어떻게 대처할 것인가

Dalvik과 Art의 차이점 참고

코틀린의 특징

startService와 bindService의 차이

프래그먼트와 액티비티의 차이

벡터 이미지 장점과 사용방법

멀티스레드 구현시 고려해야할 점

APK의 구조

GC알고리즘

즐겨쓰는 디자인패턴과 사용이유

Strict Mode에 대해서 설명 : 앱이 메인스레드에서 긴 작업을 수행할 경우 화면이 깜빡이는 디버깅모드

일반 View와 Surface View의 차이

애플리케이션의 성능을 개선한 사례

Atomic Type

람다식이란?


thread-safe한 collection, 병렬처리 컬렉션
컬랙션 프레임 워크 대부분 싱글 스레드 환경에서 사용할 수 있게 설계
Vector, Hashtavle은 동기화된 (synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드 환경에서 안전함
하지만 ArrayList, HashSet, HashMap은 멀티 스레드 환경에서 안전하지 않다
따라서 자바에서는 Collections의 synchronizedXXX() 메소드를 제공한다.

매개값으로 컬렉션을 대입하면 동기화된 컬렉션을 리턴한다.

리턴 타입		메소드(매개변수)			설명
List		synchronizedList(List list)		List를 동기화된 List로 리턴
Map<K,V>	synchronizedMap(Map<K,V> m)	Map을 동기화된 Map으로 리턴
Set		synchronizedSet(Set s)		Set을 동기화된 Set으로 리턴

단점은 동기화된(synchronized) 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만, 
전체 요소를 빠르게 처리하지는 못한다. 왜냐하면 스레드가 작업을 할때 락이 발생하기 때문이다.
 (스레드가 병렬적으로 요소들을 처리할 수 없음)
자바에서는 멀티스레드환경에서 안전하면서도, 스레드가 병렬적으로 작업을 처리할 수 있도록 
java.util.concurrent 패키지에서 ConcurrentHashMap, ConcurrentLinkedQueue를 제공한다.


안드로이드
안드로이드 매니페스트 설명
xml, view가 그려지는 과정 -> 대답 못함, measure 메소드로 사이즈를 구해서 그린다. 밖에 대답 못했음
지금 생각해보니 커스텀 뷰를 만들어봤나를 확인하는 질문인 것 같다.

constraint layout 설명
 => 레이아웃을 중첩하지 않고 유연한 방법으로 뷰를 배치하는 방법
 상대 위치 관계에 따른 배치(RelativeLayout) 과 뷰 weight 가진 장점(LinearLayout), 체인을 사용으로 다른 레이아웃 없이 그룹화
레이아웃 에디터를 활용하기 쉽고 빠르게 적용함

margin start와 left 비교 
=> 아랍어와 같은 오른쪽에서 왼쪽으로 읽는 언어가 지원 되면서 생긴거다

스타일(res -> values -> styles.xml)을 사용해봤나? 언제 사용해야 하나?
=>동일한 view 속성들을 적용하기 위해서

MVVM ViewModel과 AAC ViewModel 차이점

Room과 SharedPreferences 비교
룸은 SQlite에 대한 추상화 레이어를 제공하여 원할한 데이터베이스 액세스를 지원하는 동시에 SQLite완벽히 활용한다, db 파일저장
SharedPreferences 원시적인 데이터만 key - value 형식으로 저장 xml 파일로 저장

안드로이드 4대 컴포넌트 설명(액티비티, 서비스, 컨텐츠 제공자, 브로드캐스트 수신기)

DiffUtil(List Adapter) 어떻게 작동하나?
oldList와 newList 차이를 계산하고 oldList를 newList로 변환하는 업데이트 작업 목록을 출력할 수 있는 유틸성 클래스이다.

유진 마이어스의 difference 알고리즘을 사용하여 하나의 목록을 다른 목록으로 변환하기 위한 최소 업데이트 수를 계산

getOldListSize(): 이전 목록의 갯수를 반환합니다.

getNewListSize(): 새로운 목록의 갯수를 반환합니다.

areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): 두 객체가 같은 항목인지 여부를 결정합니다.

areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): 두 항목의 데이터가 같은지 여부를 결정합니다. 
areItemsTheSame() 함수가 true를 반환하는 경우에만 호출됩니다.

getChangePayload(oldItemPosition: Int, newItemPosition: Int): 만약 areItemTheSame() 함수가 true를 반환하고 
areContentsTheSame() 함수가 false를 반환하면 이 메소드가 호출되어 변경 내용에 대한 페이로드를 가져옵니다.

액티비티와 프래그먼트 설명

액티비티A 실행 - 액티비티B 실행 - 액티비티B 종료, 상황에서 생명주기 설명

액티비티 백 스택 설명

리스트뷰와 리사이클러뷰 비교
리스트뷰 리스트를 표한 하는 view로 재사용성이 떨어진다. 커스터마이징 하기 어렵다. 구조적인 문제로 성능 이슈도있다.
간단한 아이템 형태를 만드는 경우에는 빠르게 적용 가능하다.

리사이클러뷰
다양한 형태로 커스터마이징 할수 있다. layoutmanager와 viewHolder 패턴의 의무적 사용, item에 대한 뷰의 변형이나 애니메이션할숭 있는 개념 추가
ViewHolder 적용으로 view의 재사용이 가능

리사이클러뷰의 어댑터가 무엇인가? 무슨 역할을 하나?
RecyclerView는 Universal한 Adapter를 사용하여 데이터 소스를 처리한다. 이것은 리싸이클러뷰의 유연성을 보여준다. 다음의 3가지 인터페이스를 구현해야 한다.

onCreateViewHolder(ViewGroup parent, int viewType) : 뷰 홀더를 생성하고 뷰를 붙여주는 부분이다.
onBindViewHolder(CustomViewHolder holder, int position) : 재활용 되는 뷰가 호출하여 실행되는 메소드, 뷰 홀더를 전달하고 어댑터는 position의 데이터를 결합시킨다.
getItemCount() : 데이터의 개수 반환
getItemCount() -> onCreateViewHolder() -> onBindViewHolder() 순으로 호출된다.




이미지를 가져 올 때 캐시는 어떻게 하나? -> glide의 기본 캐시 기능을 사용했다.

개발 일반, 언어, Rx

빌드, 컴파일 설명
컴파일 타임, 런 타임 설명 -> 대답 못함, 컴파일 되는 중, 실행 되는 중 밖에 모르겠다.
java 다형성

java interface와 abstract class 차이
사용하는 용도 차이, 
동알한 부모를 가진 클래스를 묶는 개념으로 기능을 이용하거나 확장하기위해 사용
interface 해당 인터페이스를 구현한 객체들의 대한 동일한 동작으로 약속하기 위해 존재

kotlin data class, 프로퍼티 설명

캐시를 FIFO구조로 구현했는데 왜 링크드 리스트를 사용했나?, 링크드 리스트/어레이 리스트/어레이 비교

해쉬맵 설명

동시성, 비동기 설명

클래스, 인스턴스, 오브젝트 설명

Rx를 쓰면 좋은 점
장점 : 
다양한 비동기 처리 가능 -> flatmap으로 처리
복수의 비동기 처리를 완료후 결과값에 합칠때 -> merge로 처리
연속 클릭 이벤트 발생으로 인한 이벤트 중복실행 제어
콜백지옥 탈출 -> unsubscriber
모든 비동기 작업은 Observabale<T> 형식으로 해결
다양한 쓰레드 관리 가능
lambda 코드 사용하면 코드가 깔끔 

람다식(Lamdba)
장점 :효율적인 람다 함수의 사용으로 불필요한 루프문의 삭제가 가능하며 함수 의 재활용이 용이
필요한 정보만을 사용하는 방식을 통한 성능 향상
일반적으로 다중 cpu 활용하는 형태로 구현되어 병렬 처리에 유리
코드가 간결해져 개발자의 의도가 명확하게 드라나 가독성이 향상

단점 : 이론상 단순하게 모든 원소를 순회하는 경우 람다식이 느릴수 있다.
디버깅시 함수 콜 스택 추척이 다소 어렵다
지나치게 남발하면 코드가 이행하기 어렵고 지저분함
람다를 사용하여 만든 무명함수는 재상용이 불가능함

Rx가 왜 나왔나?
Rx Schedulers의 io(), computation() 설명

라이브러리와 프레임워크 차이

아키텍처, 디자인 패턴
Clean Architecture
레포지터리 인터페이스가 도메인 레이어에 있는 이유
비즈니스 로직이 뭔가?

MVP Presenter와 MVVM ViewModel의 차이, ViewModel의 개념

Databinding
Ui 요소와 데이터를 프로그램적 방식으로 연결하지 않고, 선언적 형식으로 결합할 수 있게 도와주는 라이브러리를 말한다.

repository 패턴 좋은 점

싱글톤 패턴, 옵저버 패턴

싱글 액티비티 어플리케이션 구조로 한 이유


https://onedelay.github.io/

https://m.blog.naver.com/csi468_/221465784013